# JVM运行时内存区域

## 运行时内存区域划分

![MemoryArea](C:\workspace\java-skills-book\img\MemoryArea.jpg)

运行时数据区（内存区域）包括虚拟机栈、堆、方法区、程序计数器、本地方法栈五个部分。这些区域，有的随虚拟机启动与退出而创建与销毁，有的随线程的开始与结束而创建与销毁。直接内存并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的区域，但在NIO中经常用到。

## 程序计数器

线程私有，每一个线程都有自己的pc（program counter，程序计数器）寄存器。指向当前线程所执行字节码指令地址。在执行native方法时，其值是未定义的值（undefined），这个区域是jvm中唯一不会出现OutOfMemoryError的区域。在任意时刻，一个虚拟机线程只会执行一个方法的代码，这个正在被线程执行的方法称为该线程的当前方法。

## Java虚拟机栈

线程私有，生命周期与线程相同。虚拟机栈是Java方法执行的内存模型，每个方法执行时都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每个Java方法的调用与返回，对应着一个栈帧在虚拟机栈中的入栈与出栈。 

虚拟机栈容量可以是固定的，也可以是可以动态扩展与收缩，地址空间无需保证是连续的。如果线程请求分配的栈容量超过允许的最大值，Java虚拟机会抛出StackOverflowError异常；如果Java虚拟机可以动态扩展，而在尝试扩展时无法申请到足够的内存，或在创建新的线程时没有足够的内存创建对应的虚拟机栈，Java虚拟机将抛出OutOfMemoryError异常。使用参数`-Xss`设定线程栈空间最大容量。

**栈帧**

栈帧存储了方法的局部变量表、操作数栈，同时也用于处理动态链接、方法返回值和异常分派。栈帧的存储空间由创建它的线程分配在Java虚拟机栈中，每个 栈帧都有自己的本地变量表、操作数栈和指向当前方法所属类的运行时常量池的引用。栈帧中不允许携带与Java虚拟机实现相关的一些 附加信息，如对程序调试提供支持的信息。

局部变量表与操作数栈的容量在编译期确定，并通过相关方法的code属性保存及提供给栈帧使用。线程中当前正在执行的方法称为当前方法，对应的栈帧称为当前栈帧，当前方法的类称为当前类。调用新方法时，一个新的栈帧会创建并压入Java虚拟机栈中。方法返回时，当前栈帧会传回此方法的执行结果给前一个栈帧，然后虚拟机会丢弃当前栈帧，前一个栈帧重新成为当前栈帧。

在虚拟机的概念模型中，两个相邻的栈帧是完全独立的，但大多数虚拟机的实现会做一些优化处理，令两个栈帧出现部分重叠，即让下面栈帧的部分操作数栈与上面栈帧的部分局部变量表重叠在一起，减少额外的参数复制传递。

**局部变量表**

每个栈帧内部都包含一个局部变量列表称为局部变量表，局部变量表的长度在编译期决定，并存储于类或接口的class文件中，即方法的code属性中的max_locals数据项中。

局部变量表可以保存原始数据类型、引用类型或returnAddress类型的数据。局部变量的容量以变量槽（Variable Slot)为最小单位。通常可以理解一个变量槽至少占用4个字节。long和double型变量占用两个变量槽，局部变量表使用变量槽索引位置定位局部变量。

Java虚拟机使用局部变量表实现方法参数传递。调用类方法时，方法参数依次从局部变量表中索引0定位。调用实例方法时，会自动添加this参数作为方法的第一个参数，局部变量表中的0位索引对应方法对应对象实例引用，原方法参数在局部变量表中索引从1开始。局部变量表可以重用，当局部变量超出作用域时，其占用的位置可以交给其它局部变量使用。

**操作数栈**

操作数栈也称为操作栈，是一个后入先出（Last In First Out，LIFO）的栈。同局部变量表一样，操作数栈的最大深度也在编译期时写入Code属性的max_stacks数据项中。32位数据类型占用栈容量为1，64位数据类型占用栈容量为2。栈帧在刚创建时，操作数栈是空的。字节码指令可以从局部变量表或对象实例复制变量到栈中，也有向操作数栈中取出、操作以及将运算结果入栈的指令。字节码指令是基于栈指令集，所以字节码的解释执行过程中严重依赖操作数栈。

**动态链接**

每个栈帧内部都包含一个指向当前方法所在类型的运行时常量池的引用。以便对当前方法的代码实现动态链接。在class文件的常量池中存有大量的符号引用，字节码中的方法调用指令以常量池中指向方法的符号引用为参数。这些符号引用一部分在类加载阶段或第一次使用的时候转化为直接引用，比如静态方法、私有方法、构造方法、父类方法的引用，这种转化称为静态解析。另外一部分由于涉及多态分派将在每次运行期间转化为直接引用，这部分称为动态链接。

由于对其他类的方法和变量使用常量符号引用，在运行期间进行晚期绑定，即使那些类发生变化，也不影响使用。使用晚期绑定也使Java具有强大的动态扩展能力。

**方法返回地址**

不论方法正常完成或异常完成，方法返回时，需要恢复调用者的局部变量表和操作数栈，把返回值压入调用者的操作数栈，调整PC计数器以指向调用者的下一条指令位置等。调用者的PC计数器的值会保存在栈帧中以便方法完成后恢复。

**附加信息**

可以在栈帧中保存一些用于调试的信息。一般把动态连接、方法返回与其它附加信息一起称为栈帧信息。

## 本地方法栈

线程私有，生命周期与线程相同。本地方法栈为虚拟机用到的Native方法服务。本地方法栈可以独立分配，也可直接使用Java虚拟机栈（如同Hotspot虚拟机）。同样，本地方法栈也会抛出StackOverflowError和OutOfMemoryError异常。

## Java堆

各线程共享。堆中存储了受GC管理的对象实例，容量可以固定也可动态伸缩，内存地址无须连续。当堆内存扩展时所需空间超出最大容量，Java虚拟机将抛出OutOfMemoryError异常。可以使用`-Xmx`和`-Xms`来设定Java堆最大与最小值。

在Hotspot虚拟机中，Java堆分Young代（年轻代）、Old代（老年代），JDK8之前实现方法区的年老代也在堆中。JDK8及以后，方法区由元数据区（Metaspace）实现，元数据区使用本地堆内存存放，默认最大值可达系统可用操作系统可用内存上限（操作系统的虚拟内存上限）。

* `-XX:NewSize`设置新生代初始大小。
* `-XX:MaxNewSize`设置新生代最大大小。
* `-XX:NewRatio`设置Yong 和 Old的比例。默认值为2，即Old Generation是 Yong Generation的2倍，即Yong Generation占据内存的1/3。
* `-XX:SurvivorRatio`设置新生代中的eden与survivor区域比例。默认值为8则eden区域占新生代区域的80%，两个survivor区域各占10%。

## 方法区

各线程共享。方法区存储与传统语言中代码段类似的数据，包括类信息、运行时常量池、静态变量、字段与方法数据、构造函数与普通方法的字节内容，还包括类、实例、接口初始化时用到的特殊方法。JVM规范并没有要求在这个区域实现垃圾回收，但Hotspot虚拟机实现了对方法区的垃圾回收。

在JDK8之间，习惯上很多人将方法区称为永久代，是由于JDK8之间的Hotspot虚拟机使用Java堆中的永久代来实现方法区。JDK8将永久代移除，同时增加了元数据区（metaspace），元数据区使用本地堆内存，不在Java堆中。

* `-XX:MetaspaceSize`这个参数是初始化的Metaspace大小，该值越大触发Metaspace GC（通常伴随FullGC）的时机就越晚。随着GC的到来，虚拟机会根据实际情况调控Metaspace的大小，可能增加内存也可能释放内存。在默认情况下，这个值大小根据不同的平台在12M到20M浮动。
* `-XX:MetaspaceSize`这个参数用于限制Metaspace增长的上限，防止因为某些情况导致Metaspace无限的使用本地内存，影响到其他程序。在本机上该参数的默认值为4294967295B（大约4096MB）。超过这个值将抛出一个OutOfMemoryError异常。
* `-XX:MinMetaspaceFreeRatio` 当进行过Metaspace GC之后，会计算当前Metaspace的空闲空间比，如果空闲比小于这个参数，那么虚拟机将增长Metaspace的大小。在本机该参数的默认值为40，也就是40%。设置该参数可以控制Metaspace的增长的速度，太小的值会导致Metaspace增长的缓慢，Metaspace的使用逐渐趋于饱和，可能会影响之后类的加载。而太大的值会导致Metaspace增长的过快，浪费内存。
* `-XX:MaxMetaspaceFreeRatio` 当进行过Metaspace GC之后， 会计算当前Metaspace的空闲空间比，如果空闲比大于这个参数，那么虚拟机会释放Metaspace的部分空间。在本机该参数的默认值为70，也就是70%。

**参考**

* https://www.jianshu.com/p/5ee71f1724cd
* https://blog.csdn.net/xlnjulp/article/details/46763045



**运行时常量池**

类文件结构除了版本号、字段、方法、超类、接口等各种信息，还有一项信息就是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容在类加载后存放在方法区的运行时常量池中。 编译期的类、方法、字段等符号引用必须到运行时才能获取具体的引用地址。运行时常量池类似于传统语言中的符号表，不过包含内容更广泛。

运行期间也可以有其它的一些内容放入常量池中，比如字符串常量池，自jdk8已经移入Java堆中。加载类时，需要的内存空间超出了方法区的最大值，那么Java虚拟机将抛出一个OutOfMemoryError异常。

## 直接内存

JDK1.4新加入了NIO类，引入了一种基于通道（channel）与缓冲区（Buffer）的IO方式，它使用Native函数直接分配堆外内存。这样避免了在Java堆与Native堆之间复制数据，显著提高了性能。

直接内存不受Java堆大小的限制，但会受到本机总内存（RAM及SWAP）限制，当系统内存耗尽时会出现OutOfMemoryError异常。

